

# 简介
字符串的题目目前可以分为两类:  
- 一类是对字符串本身进行操作 包括翻转字符串(双指针) 字符串匹配(KMP)等等
- 另一类是将字符串与数字、字母等之间进行转换 然后进行操作 需要考虑比较多 考验对代码的掌控能力

这里分别介绍两类题目 关于第二类 不是很懂 每次写出来的代码总是很乱 第一类倒是都有关键的算法 掌握就好 而且再不济还有库可以调

# 第一类
- 回文串：中心扩展法
- 字符串匹配：KMP/字符串哈希
- 周期字符串：KMP/双倍字符串
- 前后缀：KMP
- 翻转字符串：双指针
可以看出KMP很重要了.....虽然也很难就是了

## LC5 最长回文字串
同类型的还有LC647 回文字串 都是求一个字符串中的回文字串  
关键在于如何判断一段字符串是否为回文串  
回文串定义：正序读和逆序读是一样的 也就是说是左右对称的
1. 中心扩展法<br>
观察回文串的特点可知 回文串的中心均为1或2个字符 因此遍历所有的1个与2个相邻的字符 并向两边扩展 直到两边的字符不再匹配 
<details>
<summary>Code5 中心扩展法</summary>
<pre><code class = "language-cpp">
class Solution {
public:
    string longestPalindrome(string s) {
        // 中心扩展法求回文串
        // 回文串的中心要么是1 要么是2 都试一遍即可
        int start = 0;
        int end = 0;
        for(int i = 0; i < s.size(); i++) {
            auto [left1, right1] = expand(s, i, i);
            auto [left2, right2] = expand(s, i, i + 1);
            if((right1 - left1) > (end - start)) {
                end = right1;
                start = left1;
            }
            if((right2 - left2) > (end - start)) {
                end = right2;
                start = left2;
            }
        }
        return s.substr(start, end - start + 1);
        
    }
    pair<int, int> expand(string s, int i, int j) {
        while(i >= 0 && j < s.size() && s[i] == s[j]) {
            i--;
            j++;
        }
        return {i + 1, j - 1};
    }
};
</code></pre>
</details>


## LC686 重复叠加字符串匹配
这一类题主要是匹配问题 最通用的方法就是KMP算法以及字符串哈希算法<br>
题意：给定两个字符串a, b 重复叠加a使得b是叠加后的a的字串 求出这个最小叠加次数 若不存在则返回-1
1. KMP<br>
先放个参考链接：
https://zhuanlan.zhihu.com/p/105629613 <br>
KMP算法的主要由两部分构成：求出PMT数组 以及 利用PMT数组匹配模式串与字符串<br>
- PMT数组实质上表示的是最长公共前后缀的长度 这样在匹配不成功的时候 由于已经计算出了PMT即最长公共前后缀 虽然此时最后一个字符匹配不成功 但是前面的已经匹配完成 且有公共前后缀 所以可以不必重头匹配 而是跳到公共前后缀后一位开始匹配 因为模式串的前缀 = 模式串的后缀 = 待匹配的后缀 所以可以直接跳
- 所以现在的关键在于如何求出PMT数组(Partial Matching Table)也被叫做next数组
- 求PMT数组的思路在于将模式串与模式串本身进行匹配 错开一位之后 原来的模式串参与匹配的是后缀 而下面的模式串参与匹配的是前缀 所以在相等时 长度加1 而且这个长度就是PMT[i]的值 若匹配不成功 则和匹配时一样 利用已经求出的前面的PMT进行回退 直到匹配成功或者回退到了原点(此时表示没有公共前后缀 即需要重头匹配)

<details>
<summary>KMP算法模板</summary>
<pre><code class = "language-cpp">
// 模式串匹配算法
for(int i = 0, j = 0; i < s.size(); i++) {
    while(j && s[i] != p[j]) j = pmt[j - 1];
    if(s[i] == p[j]) j++;
    if(j == p.size()) j = pmt[j - 1];
}

// 计算PMT数组 算法 即将自身和自身错开后匹配
// pmt[0] = 0
for(int i = 1, j = 0; i < p.size(); i++) {
    while(j && p[i] != p[j]) j = pmt[j - 1];
    if(p[i] ==  p[j]) j++;
    pmt[i] = j;
}
</code></pre>
</details>


2. 字符串哈希<br>
字符串哈希主要是一种查询上的优化 匹配字符串本质上是匹配所有的字串与模式串 首先遍历所有的字串需要O(n^2)的复杂度 若与模式串一个一个匹配 则有O(n^2 * m)的复杂度 因此可以将一个字符串映射为一个数字 则匹配字符串O(m)的复杂度就变成了O(1)<br>
所以现在的关键就是如何将字符串映射到数字 这里用的是哈希 首先我们对于任意1个十进制数 都可表示成$\sum a_i * 10^i$ 的唯一形式 因此 我们选择一个素数作为Base即进制的基底 然后再选一个模数防止溢出 一般这里选择2^64 - 1
由于每个字符都表示一个数字 因此可以计算出每个前缀的hash值

好吧 这块还没有很懂 下次继续写 主要是这几次做题都没有用到这个 一般KMP就可以解决


## LC459 重复的子字符串
给定一个非空字符串s 检查是否可以通过由他的一个字串重复多次构成
对于这类周期字符串的问题 有两种方法可以验证
- 双倍字符串
这里其实很巧妙 我们有如下结论：<br>
若s的双倍字符串即 s1 + s2 中存在子字符串为 s 则可以判断 s 为周期字符串 <br> 
(s1 = s2 这里只是为了更好的说明加以区分)<br>
  因为 s 可以匹配 s1 + s2 的字串 所以存在一种错位 使得 s 的后半部分可以匹配 s2 的前半部分 又因为 s1 的后半部分匹配 s 的前半部分 且 s1 = s2 所以有 s 的前半部分匹配 s 的后半部分 即 s 为周期串 

所以只需匹配s 与 s + s即可 当然开始匹配的位置不能是0 或者s.size()

- KMP
KMP的基本概念前面已经解释过 这里给出一个结论:<br>
当 s 为周期串时 有 (s.size() - 1 - pmt.back()) | s.size()
即s的长度为 最后一个前缀的长度 - 最长公共前后缀的长度 的倍数


## LC344 反转字符串
给定一个字符串s 原地修改数组 翻转s<br>
原地翻转这一类主要是利用左右双指针 交换字符串两边的字符 直到两边的指针相遇

<details>
<summary> LC344 </summary>
<pre><code class = "language-cpp">
    void reverseString(vector<char>& s) {
        int left = 0;
        int right = s.size() - 1;
        while(left <= right) {
            swap(s[left], s[right]);
            left++;
            right--;
        }
    }
</pre></code>
</details>


# 第二类
- 字符串与数字转换:<br> 
外观数列 罗马数字 计算数学表达式 求解方程 分数加减法 最优除法 负数乘法 
- 高精度数字:<br>
二进制求和 字符串相加 字符串相乘(这类题目由于字符串可以很长 所以无法直接转换成int进行操作)
这类题目没有固定做法 一般就是模拟 不过好难！！！每次代码都写得又臭又长