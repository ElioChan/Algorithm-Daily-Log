# 简介
这篇主要介绍有关动态规划的问题 借鉴别人说的一句话：动态规划的问题本质上考察的是如何转化为<mark>背包问题</mark>  
因此动态规划的主要分为两部分：  
1. 背包问题
2. 转化为背包问题

对于背包问题，有很多的种类，最基础的是0-1背包问题，其他的暂时还没有接触到，所以下面介绍0-1背包问题

# 背包问题
背包问题泛指一类 给定价值与成本 并 限制决策规则, 问如何实现价值最大化
## 0-1背包问题
0-1背包问题值给定物品价值与体积(对应给定价值与成本)，在规定的背包容量下(对应限制决策规则)，如何选择装入背包的物品使得价值最大  
我们考虑一个二维数组dp[i][j]表示在前i件物品种选择装入容量为j的背包 如何实现价值最大化 那么0-1背包问题就是返回dp数组的右下角的值  
对于第i+1个物品 我们有两种选择：装入背包或者不装   
若装入背包 则dp[i+1][j] = dp[i][j - weight[i + 1]] + value[i + 1] 即利用前i件物品装入背包容量为j - weight[i]的最大价值 再加上物品i的价值  
若不装入背包 则dp[i+1][j] = dp[i][j] 因为没有装入第i+1件物品 所以和前i件物品的选择是一样的
同时我们要求最大化 所以dp[i+1][j] = max(dp[i][j], dp[i][j - weight[i + 1]] + value[i + 1])

通过上述的递推的方式即可得到整个dp二维数组 前提是需要对dp数组进行初始化 一般是第一列以及第一行 具体视题目而定  
对于0-1背包问题的话就是 第一列表示容量为0 则无法装入任何东西 因此价值为0; 第一行表示只考虑是否装入第一件物品 所以若容量大于第一件物品重量 则价值为第一件物品的价值

<mark>优化为一维数组</mark>
对于上述地推过程，我们可以发现对于第i+1行的dp数组 只用到了第i行的dp数组进行计算  
因此我们考虑用一维数组进行优化 即dp[w] = max(dp[w], dp[w - weight[i]] + value[i])
由于我们需要用dp[w - weight[i]]这个数据 而这个数据是第i轮的数据 在第i+1轮计算时 若从左往右遍历 则这个值会被修改 因此我们需要从右往左遍历
<strong>dp[w]要调用的是第i层循环还没有更新过的值</strong>

## 完全背包问题
相比于0-1背包问题，完全背包问题对于物品可选择的次数不做限制，即0-1背包问题每样物品只能用一次，选择放与不放; 而完全背包问题每件物品可以多次选择，可以选择不放或者放一件 放两件 放三件......  

这里直接看完全背包问题的一维数组的情况，在0-1背包问题中，外层循环是物品，内层循环是背包容量，而在其一维数组的情况中我们内层循环是从后往前遍历的， (之前解释过，从后往前遍历是为了保证每个物品只被选择一次，因为在递推公式中需要用到的数据是第i-1轮的数据 若从前往后 则调用的数据变成了第i轮的数据 相当于一个物品重复考虑了)   
而在完全背包问题中，我们对于物品选择的次数不再做限制，即每个物品可以多次选择，所以我们双层循环依然都是从前往后遍历，但是内外层循环的先后顺序会有变化，在0-1背包问题中由于内层对于背包容量的循环是从后往前的，固定了每个物品只能选择一次，所以内外循环互换顺序不会造成影响; 但是对于完全背包问题，就会有影响了，这里先给出结论：
1. 外层遍历物品，内层遍历背包容量————求组合数(即不考虑顺序)
2. 外层遍历背包容量，内层遍历物品————求排列数(即考虑顺序)    

例子LC518 零钱兑换II  
题目要求：给定coins数组以及目标target 求有多少种组合可以得到target  
分析：这题不是单纯的完全背包问题(求是否能够装满背包 或者说背包可以得到的最大价值 递推公式为dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 需要注意对于单纯的完全背包问题 交换内外层顺序也是没有关系的) 而是求装满背包的组合数 所以递推公式为dp[j] += dp[j - coins[i]]   

若我们先遍历背包容量即target， 再遍历coins 则我们会一个一个确定dp[j]的值 因此后面的dp[j]在计算时调用前面的值 调用的是最终的结果 所以会有重复的元素出现 即认为同一个元素在不同的位置出现表示两种不同的结果 即注重顺序的排列  

而若先遍历coins， 再遍历背包容量target， 则我们会每一轮种依次更新dp[j]以及dp[j]前面的值 也就是说他每一轮都是在变的 所以不会重复的选取一个元素



