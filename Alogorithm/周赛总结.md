# 周赛307
2022/8/21
这周又是签到题选手 呜呜呜呜太难了 不过比前两次好多了 前两次完全没有思路 只能看着大佬在评论区里面谈笑风生
这次第一题就花了我18分钟 还WA了一次 这个时候大佬都已经全部AC了......
主要原因还是自己的代码功底不够 类似第三题 思路是有的 不过完全不知道该怎么重构二叉树 毕竟有些节点会有三个子节点 而且怎么逆转方向？？？
还有第四题 和之前做过的前K个高频元素很像 大概猜到是用堆来做 不过没敢想 T4不是现在的我可以企及的 第二题的话 大致的思路是有的 不过对对于不能有前导零这一点不会处理 当时想着是把有零的情况单独拿出来讨论 后面发现生成回文的思路就不太对

## T1 LC6152 赢得比赛需要的最少训练时长
一眼贪心嘻嘻 和之前做的LC134 加油站很像 基本一样
对于精力 由于只会消耗 不会增加 所以遍历一边数组求出需要消耗的精力和+1 - 初始的精力即为需要训练的时间
对于经验 由于击败对手后经验会增加 这个就和加油站类似了 关键在于求出最少需要的初始经验
从头遍历经验数组 res = max(res, experience[i] + 1) ; res += ecperience[i] 即可 就是说每到一个对手面前 比较已有的精力和至少需要的精力 取最小值 然后击败对手后 此时的经验即击败对手i需要的最少的经验 再加上经验i 比较和下一个对手 击败最后一个对手后 就得到了 击败所有对手所需要的经验 这个时候减去所有对手的经验之和 即为我们自己初始所需要的经验 

这题WA了一遍的原因在于上面那两个最后结果的减法没有判断是否小于零 这里小于零就代表题目给的初始值已经够了 不需要训练

## T2 LC6166 最大回文数字
给定一个仅有数字0-9组成的字符串Num, 找出能够使用Num中数字形成的最大回文整数并以字符串的形式返回 该整数不含前导零 

- 原始思路：统计所有数字出现过的次数 所有偶数次的放两边 奇数次的挑一个最大的放中间 最后返回even + odd + reverse(even)  
问题在于奇数次的比如3可以选用2个变成偶数次 
- 题解思路：统计所有数字出现的次数 从9往0遍历 将所有的数字次数-2 然后放进结果left = right 最后所有的数字的count为1或者0 然后再从9往0遍历 遇到1就放进left后面然后结束 最后返回left + right  
对于前导零的处理在于第一次从9往0遍历时 若left为空 且遍历到0了 则终止 因为此时的0读进来为前导零

## T3 LC6154 敢让二叉树需要的总时间
- 原始思路：这个总时间应该等于以目标节点为根节点的树的深度 求深度 会！ bfs  但是不会重新构建一个以目标节点为根节点的树 然后就卡住了
- 题解思路：构建一个关联矩阵 表示每个节点与那些节点向量 然后使用dfs遍历这个图 计算最大深度
1. 为了构建关联矩阵 需要直到维度 所以第一次dfs遍历得到节点的最大只
2. 构关联矩阵 遍历dfs加入每个节点与那些节点相连
3. 遍历关联矩阵dfs得到最大深度


# 周赛308
2022/9/1
由于这次周赛做出来三题所以飘了 所以忘记记录  今天补一下
这次是三题选手 嘻嘻嘻 第一题花的时间有点久 第二题倒是很快就做出来了 第三题一开始看错题目了 后面由于罗老师开会要共享屏幕 所以没办法改 结果只能会开完再改 就来不及了 不过最后还是改出来了 就算自己做出来了嘻嘻

## T1 LC2389 和有限的最长子序列
题意：给定一个数组num以及一个数组query 要求求出num中值不超过query[i]的最长子序列的长度
- 原始思路：由于是求自序列的长度 一开始想的是动规 但是不会写 然后想到贪心 因为是子序列 所以无关顺序 所以可以将原数组进行排序 然后求前缀和 这样可以保证求出来的序列是最长的  之所以花了28分钟才做出来 是因为之前思路太乱了 一直试图用动规做 但是找不到递推公式 所以就放弃动规了

## T2 LC2390 从字符串中移除星号
题意：给定包含若干个星号*的字符串s 每次移除星号 *左边的字符 并移除星号本身
- 原始思路：就是栈的简单应用 依次读取字符 遇到星号就pop出栈顶元素即可 然后这题本来需要一个栈存储读取的元素 之后再从栈中恢复字符串 但是前几天刚好做到一个题看到一个题解说是 字符串直接有栈的操作pop_back() push_back() 所以就不需要栈作为中介了

## T3 LC2391 收集垃圾的最少总时间
题意：三种垃圾由三种垃圾车进行回收 给一个字符串数组表示第i户人家的垃圾种类与数目 比如'MPGG'表示G玻璃垃圾有2单位 M金属垃圾有1单位 纸垃圾有1单位
三类垃圾车回收一单位垃圾需要一单位时间 然后再给一个时间数组表示每辆垃圾车在相邻的房子之间需要行驶的时间 三辆车速度一样 每次只能一辆垃圾车在行驶或者收拾垃圾 且从同一个起点出发 问至少需要多少时间处理所有的垃圾
- 原始思路：直接贪心 由于收拾垃圾时间等于字符串的长度之和 所以直接相加即可 剩下的就是每辆车的行驶时间 只要计算出最远出现对应垃圾的下标 再计算一下行驶时间数组的前缀和即可得到行驶时间 一开始看错题目以为是每类垃圾车时间不同 直接搞错题意 所以一直通不过示例 后来想通了 又去开会了 最后写出来了 不过代码可以优化 可以看出三辆垃圾车需要做的事是相同的 所以可以写个函数 调用三次 这样可能更快

## T4 LC2392 给定条件下构造矩阵
emmm没看题目 下次再说吧


# 周赛309
mihoyou的题好难 参加的人好多....又是1题选手 不过竟然还有前4000....这次的第二题和第三题确实没有思路 主要是卡在第二题 有一点思路又没有完全有 就想了很久
第一题就不讲了
## T2 LC6168 恰好移动K步到达某一位置的方法数目
题意： 给定两个位置startPos 和 endPos，以及步数k,问有多少种走法可以走k步从start走到end 每次走一步
- 原始思路：一开始想的用动规 试图找到走k步和走K-1步之间的关系 最后没找到 然后手动模拟了以下例子 发现只有当k-d是偶数的时候才可以有多种走法 因为多种走法的实质是从start走到end的这段长度为d的路程中 多出来的k - d步需要在某些点上走一个来回 比如1->2走三步 可以1->2->1->2 或者1->0->1->2 也就是在1这个点走了一个圈然后再回到普通的路线1->2上 所以我就开始找这个规律 有多少种走圈的走法 结果最后还是没找到
- 题解：将设沿着从start往end的方向走了a步 反方向走了k-a步然后到达了end 则一共有C(a, k)种走法 即在k步种选择a步时沿正方向走 同时我们根据距离有 
a - (k - a) = abs(end - start) = d  ==> a = (k + d) / 2因此只有k + d为偶数时才有可能走多步 这个和我之前发现的规律是一致的
因此最后就转变为求C(a,k)可以利用组合数的公式C(j,i) = C(j, i - 1) + C(j - 1, i - 1)进行递归计算

## T3 LC6169 最长优雅子数组
Tag: 位运算
题意：给定一个正整数组成的数组，找出其中的最长优雅子数组
优雅：即数组种任意两个元素按 与 运算结果为0  (即任意两个元素 二进制表示中的1的位置不同)
子数组：数组种连续的一部分
- 题解：由于是求子数组 连续的 所以考虑滑动窗口
关键点：本质上要求滑动窗口里的元素的相同的位的上不能有重复的1 因此可以将所有的元素进行或运算 或运算 会将所有的1都统计出来 因此只要新加入窗口的元素与所有元素的或运算后的结果 的与运算 == 0 即可 若要移动窗口左边界 即将元素剔除出去 可以利用异或运算 因为此时窗口内部是优雅的 即每一位上至多只有一个元素为1 所以利用异或剔除左边边界元素所包含的1即可
 


 # 周赛310 
 2022/9/13
 上周末又忘记及时记录了.....好吧 今天补上<br>
 这次周赛忘记了...尴尬 到11.30才想起来 然后顾不上吃饭 匆匆忙忙打开力扣做题 一看时间 嚯 大佬们10分钟解决战斗 还有一个WA了一次 还是11分钟结束战斗...厉害 看来还是手速场 感觉最近稳定2题选手了 第三题每次看题解能学到一些东西<br>
 然后就是这次 看来排名第一的大佬的代码 真的学到很多！！！

 ## T1 LC2404 出现最频繁的偶数元素
 题意：给定一个整数数组 返回出现最频繁的偶数元素 若存在多个 返回最小的 若不存在 返回-1<br>
 思路：利用hash表 边存边更新最频繁的结果

 这里比赛的时候之所以选择边存数据边更新结果 主要是因为自己不知道怎么遍历哈希表.....太菜了
 for(auto& [k,v] : mp) if(v > ansv) ans=k, ansv=v;

 ## T2 LC2405 子字符串的最优划分
 题意：把字符串划分为一个或多个子字符串 要求每个子字符串中每个字符都是唯一的 即只能出现1次 返回最少的子字符串数量<br>
 思路：维护一个子字符串 然后遍历原字符串 若子字符串中出现过字符 则将子字符串加入vector 并清空子字符串 否则就将字符加入子字符串 最后返回vector.size()即为字符串的数量<br>
 大佬的题解：学习！ bitset <br>
 bitset类由一些位组成 可以看作是一个0-1vector 下标为0表示最高位 不过这个类可以直接提供一些位运算以及比特的设置<br>
 - set()将所有位都设为1, set(size_t pos, bool val = true)将第pos位设为val
 - reset()将所有位都设为0, reset(size_t pos)将第pos位设为0
 - flip()将所有位都翻转(0->1, 1->0), flip(size_t pos)翻转第pos位
 - test(size_t pos) const;测试第pos位是否为1
 - bool any() const; 判断是否有某位为1
 - bool none() const; 判断是否全部为0
  ```
class Solution {
public:
    int partitionString(string s) {
        int ans=0;
        std::bitset<128>vis;
        for(char c:s){
            if(vis[c])ans++,vis.reset();
            vis.set(c);
        }
        return ans+1;
    }
};
  ```
大佬这个写法其实思路差不多 不过使用了bitset来实现 因为字符串的ASCII范围在0-127 所以设了一个128位的bitset来表示每一位是否出现过

 ## T3 LC2406 将区间划分为最少数组
 Tag: 贪心
首先将数组按照左边界升序排序 维护一个表示每组结束时间的列表
新加入的区间的可以接在所有结束时间小于他的开始时间的组的后面 若存在 则一定包含结束时间最小的那个组 我们统一选择接在结束时间最小的组的后面 
- 其实只要存在这样的组 则接在那一组后面都是没差别的 假设又两个组的结束时间为a < b 此时新加入的区间[c, d]满足a < b < c <= d 则由两种接法 a -> c或者 b -> c 由于我们之前按照左边界升序排序  所以后面加入到区间的开始时间e >=c  若 e > d则可以选择a或b组都可以 若我们之前选择a->c 则这次选择b->e ； 若之前选择b->c 则这次选择a->e 可以看出选择a->c 或b->c并没有差别
接在结束时间小的组后面 同时更新这一组的结束时间

通过上述分析 可以选择维护一个结束时间的小顶堆 
- 当新的区间的开始时间大于堆顶 即最小的结束时间 更新那一组的结束时间 即pop堆顶 加入新区间的结束时间  
- 当新的区间的开始时间小于堆定 即最小的结束时间 则小于所有的结束时间 因此需要增加一组

###  priority_queue
初始化：
priority<int> pq; 默认是大顶堆 底层容器默认为vector 也可以用deque
priority<int, vector<int>, greater<int>> pq;  若要使用小顶堆 第三个参数要用greater<type> 同时 C++中参数半缺省只能缺省右边的连续的参数 所以不能缺省中间的vector<int>参数