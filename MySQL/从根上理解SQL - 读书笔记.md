

# Chap9 表空间
InnoDB是以页为单位管理存储空间 聚簇索引以及二级索引都是以B+树的形式存在表空间里面 而B+树的节点就是数据页<br>
页面通用结构：首尾分别为File Header、File Trailer
- File Header记录一些页面的通用信息
- File Trailer校验页是否完整

## 独立表空间结构
区(extent): InnoDB中为了更好的管理页 设计连续的64个页为一个区 一页为16KB 因此一个区默认占1MB的空间 同时256个区被划分为一组 每个表空间都可以看做是若干个区组成的 同时每个组最开始的几个页面类型是固定的为XDES IBUF_BITMAP 第一个组中还有FSP_HDR这个类型的页面 用于记录整个表空间的一些整体属性 以及 本组所有的区的属性

段(segment): B+树的叶子节点和非叶子节点分开存储 存放叶子节点的区的集合算一个段

设计 区 和 段 的目的：
- 区: 由于表空间主要存储的就是聚簇索引以及二级索引这些数据 我们往表中插入数据 聚簇索引以及二级索引都需要插入数据 若表中数据量很大 需要存很多页 则我们在插入数据时 需要找到插入的位置 又因为页并不是连续的 因此 会造成插入数据性能低下(在插入数据时 要根据插入的值利用二级索引查找主键值 找到主键值后 从节点之间的链表遍历到查找的位置 由于表在物理空间上并不是连续存储的 所以这个遍历过程可以看作随机I/O 效率低下) 因此我们设计区为连续的页面 把数据存在连续的页面中提高性能 虽然当数据量少的时候 由于区的大小固定可能会造成空间浪费 但是从性能角度上看 功大于过
- 段: 之前提到的遍历 其实是对叶子节点的遍历 而不用管非叶子节点 因此将两部分数据分成两个区存 这就是段了 所以一颗B+树会生成两个段 一个是叶子节点段 另一个是非叶子节点段 但是当表中数据较少时 若按上面的分配方式 至少需要为一张表分配2M的空间 过于浪费 因此又设计了碎片区 碎片区的页并不单一的属于某一个段 而是分属于不同的段 碎片区直属于表空间 并不属于任何一个段
  - 根据如上规则插入数据：
  - 在刚开始向表中插入数据时 段是从某个碎片区以单个页面为单位来分配存储空间
  - 当某个段已经占用32个碎片区的页面 即一半后 就会以完整的的区为单位来分配空间
- 所以段的定义为某些零散的页面以及一些完整的区的集合

表空间是由若干个区组成的 可以划分以下四种类型
- 空闲的区(FREE)：没有用到任何区中的页面
- 有剩余空间的碎片区(FREE_FRAG)：仍有空闲页面的碎片区 
- 没有剩余空间的碎片区(FULL_FRAG)：碎片区中的所有页面都被使用
- 附属于某个段的区(FSEG)：用于记录某一个索引的叶子节点或非叶子节点的段中的区

前三者是独立的，直属于表空间; FSEG是附属于某个段的

XDES Entry(Extent Descriptor Entry): 用于记录区的属性，共40字节，分为以下4部分
- Segment ID(8字节)：若该区属于某个段 则记录段的ID 否则无意义
- List Node(12字节): 用于记录指向前一个XDES和后一个XDES的指针 即利用这个字段将区和区之间像链表一样连起来 定位一个XDES需要两个信息：next node page number 以及 next node offest 即找到下一个节点所属的页面以及页内偏移
  - <details> <summary> XDES Entry链表的作用 </summary> XDES Entry链表主要作用为快速定位到XDES Entry。<br> 1. 对于直属于表空间的三种区，段中数据较少时，插入数据，首先寻找表空间中的FREE_FRAG的区 若存在 则插入数据 否则申请一个FREE的区 然后把该区变为FREE_FRAG。之后不同的段会从该区申请页面 直到没有空闲的也买你 把状态改为FULL_FRAG。当表空间数据量很大时 查找是否存在FREE_FRAG的区若是通过遍历表空间所有区的状态 会导致效率十分低下 因此考虑将直属于表空间的三种状态的区连接成三个链表: FREE/FREE_FRAG/FULL_FRAG; 这样想要查找FREE_FRAG的区的时候 直接访问FREE_FRAG链表的头节点即可 当该节点中的页面用完的时候 就修改state值 然后移动到FULL_FRAG链表中即可 这样就大大提升了效率。<br> 2. 对于附属于某个段的区，当段中数据已经沾满32个零散的页面后 申请一个完整的区来插入数据。此时我们需要找到属于该段的区存储数据 如何找到属于该段的区？ 利用链表 但这里构建链表是根据XDES Entry中的Segment ID属性， 因为不同的段中的数据不会存在同一个区中 同时一个段中的区也有三种状态: FREE/ NOT FULL/ FULL 因此每个段都需要维护三个链表 而一个索引对应两个段 因此一个索引需要维护6个链表 同时不要忘记直属于表空间中的3个链表 <br> 3. 链表基节点。链表基节点用于定位链表 存有以下信息 <br> - List length(4字节) 表明该链表中有多少节点 <br> - First node page number 和 First node offest表明该链表的头节点在表空间中的位置 <br> - Last node page number 和 Last node offest表明该链表的尾节点在空间的位置 <br> 最后链表基节点会存在表空间中的固定位置便于访问
- State(4字节): 记录区的状态 即之前那4个状态(emmmm竟然只用记录4总状态 为什么需要4字节？？？)
- Paeg State Bitmap(16字节): 记录区中64个页面的信息 16字节一共128bit 所以一个页面的信息占2bit  一个比特位用于记录页面是否空闲 另一个还没有用

段的结构：<br>
之前给过段的定义：一些零散的页面以及一些完整的区的集合。下面给出段的结构用于记录段中的这些信息， 这个结构叫做INODE Entry<br>
- Sgemment ID: 段的ID
- NOT_FULL_N_USED: 用于记录NOT_FULL链表中已经使用了多少页面 这样就不用从链表的第一个页面开始遍历寻找空闲页面
- FREE/NOT_FULL/ FULL三个链表基节点
- magic number: 标记这个INODE Entry是否初始化
- Fragment Array Entry: 用于记录段中零散的页面的页号 一共记录32个页号 每个4字节 因为当零散的页面超过32个的时候 就会申请一个完整的区用于记录数据

表空间整体结构：表空间由组构成 每个组有256个区 每个区有64个页面 <br>
其中第一个组的第一个区的第一个页面比较特殊 会记录表空间的整体属性 这个页面是FSP_HDR(File Space Header) 和其他组的第一个页面相比 多了一部分就叫做File Space Header的信息 当然其他组的第一页中也有这部分空间 不过为空<br>
- File Space Header(第一组第一页特有)：
    - 表空间的三个链表基节点
    - FRAG_N_UESD 表示链表Free_FRAG 中已经使用的页面数量 方便之后在链表中查找空闲的页面
    - FREE_LIMIT 表示初始化时加入FREE链表的页面数量 一开始创建表空间的时候 不会讲所有的空闲区都加入链表 而是至添加一部分 等到后续不够了 再添加
    - NEXT UNUSED Segment ID 每个索引都对应两个段 每个段都有一个叫做Segment ID的参数 通过next unused id来赋值 否则的话需要遍历空间中所有的ID找到没有被用过的ID赋值 降低效率
    - List Base Node of SEG_INODES_FULL/FREE List 用于存放INODE类型页面链表的基节点 INODE类型的页面适用于存储 INODE Entry结构 这个结构是段的信息结构 用于存放段的信息 包括三条链表的基节点以及零碎页面的信息
- XDES Entry
  - 这个部分主要存储当前组中256个区的信息 由于一个页面的大小有限 因此限制一个组为256个区 同时只有每个表空间的第一个组存在 FSP_HDR这个类型的页面存放XDES Entry部分 其余组的第一个页面都直接就是XDES类型 用于存储XDES Entry信息 结构和FSP_HDR类似 不过少了File Space Header部分的信息


## 系统表空间结构


# Chap10 单表访问方法
这章主要将对一个表进行查询操作时 Mysql会如何执行查询优化

访问方法主要有几下几种

1. const

主键列(聚簇索引) 或者 唯一二级索引(即每个索引值是唯一的) 和一个常数进行等值比较时使用const方法

2. ref

普通的二级索引 与 常数 进行等值比较

3. ref_or_null

二级索引不仅想找出某个常数值的记录 还有 null的记录

4. range

索引列匹配某些值 或者 某个范围的值 时使用range

5. index

遍历二级索引的查询 即不需要返回所有列的数据 查找的数据被二级索引列覆盖即可

6. all

全表遍历 即对聚簇索引遍历查找

Remark:
- 一般情况下只能用一个二级索引进行查询 当你要查两个不同的列时 会先利用一个二级索引进行查询 然后回表 在聚簇索引中利用主键值进一步过滤第二个条件
- 在range查询中 只要索引和常数使用操作符= <= >= .... in like等连起来 就可以产生一个区间 不同的条件需要使用AND 或者 OR连接起来 
  - 当所有的搜索条件都可以用一个二级索引进行查询 比如 where key2 > 100 AND key2 > 200 此时查询会取交集  若是OR 则回去并集
  - 有的搜索条件没有索引时 比如 where key2 > 100 AND common filed = 'abc' 其中只有Key2建立了索引 则查询优化会将其替换为TRUE 即先不考虑 这个条件 但是若这里是OR 就会变成了key2 > 100 OR TRUE = TRUE 就变成了遍历二级索引了 这样回表的操作就会很低效 即一个使用到索引的搜索条件和一个没有使用索引的搜索条件用OR连接起来后是无法使用索引的
- 索引合并
  - 之前说过一般情况下只会使用一个二级索引 但有些特殊情况是会使用多个的
  - Intersection合并 即将两个二级索引的搜索结果的主键值先求交集 再回表查询 只有下列情况可能会使用索引合并(注意 这里是可能 就是说就算满足这些条件也可能不使用索引合并进行查询优化)
    - 二级索引列都是等值匹配的情况
    - 主键列可以是范围匹配
    - 这里可以用的原因主要在于当索引列都是等值匹配的时候 回表的主键值其实是递增排序的 因此求两个的交集是O(n)的复杂度 很快
  - Union合并 上面是求交集 这里就是求并集了
    - 二级索引列都是等值匹配
    - 主键可以是范围匹配
    - 使用Intersection索引合并的搜索条件 就是说有两部分 每部分都是Intersection的结果 然后这两部分用OR连接
  - Sort-Union合并 整体也是求并集 不过这里不是等值匹配 而是范围 是将范围搜索得到的结果进行排序后再按照Union合并
    - 这总方式比单纯的Union合并多了一步排序的的工作
    - 注意到Intersection合并是没有Sort的  因为Union合并的适用场景是从某个二级索引中获取 的记录比较少 这样就算排序也不会有太大的消耗 而Intersection合并 是值单个的索引获取的记录太多 通过求交的方式减少一部分 如果还要排序 消耗就太大了