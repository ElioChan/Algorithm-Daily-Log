

# Chap9 表空间
InnoDB是以页为单位管理存储空间 聚簇索引以及二级索引都是以B+树的形式存在表空间里面 而B+树的节点就是数据页<br>
页面通用结构：首尾分别为File Header、File Trailer
- File Header记录一些页面的通用信息
- File Trailer校验页是否完整

## 独立表空间结构
区(extent): InnoDB中为了更好的管理页 设计连续的64个页为一个区 一页为16KB 因此一个区默认占1MB的空间 同时256个区被划分为一组 每个表空间都可以看做是若干个区组成的 同时每个组最开始的几个页面类型是固定的为XDES IBUF_BITMAP 第一个组中还有FSP_HDR这个类型的页面 用于记录整个表空间的一些整体属性 以及 本组所有的区的属性

段(segment): B+树的叶子节点和非叶子节点分开存储 存放叶子节点的区的集合算一个段

设计 区 和 段 的目的：
- 区: 由于表空间主要存储的就是聚簇索引以及二级索引这些数据 我们往表中插入数据 聚簇索引以及二级索引都需要插入数据 若表中数据量很大 需要存很多页 则我们在插入数据时 需要找到插入的位置 又因为页并不是连续的 因此 会造成插入数据性能低下(在插入数据时 要根据插入的值利用二级索引查找主键值 找到主键值后 从节点之间的链表遍历到查找的位置 由于表在物理空间上并不是连续存储的 所以这个遍历过程可以看作随机I/O 效率低下) 因此我们设计区为连续的页面 把数据存在连续的页面中提高性能 虽然当数据量少的时候 由于区的大小固定可能会造成空间浪费 但是从性能角度上看 功大于过
- 段: 之前提到的遍历 其实是对叶子节点的遍历 而不用管非叶子节点 因此将两部分数据分成两个区存 这就是段了 所以一颗B+树会生成两个段 一个是叶子节点段 另一个是非叶子节点段 但是当表中数据较少时 若按上面的分配方式 至少需要为一张表分配2M的空间 过于浪费 因此又设计了碎片区 碎片区的页并不单一的属于某一个段 而是分属于不同的段 碎片区直属于表空间 并不属于任何一个段
  - 根据如上规则插入数据：
  - 在刚开始向表中插入数据时 段是从某个碎片区以单个页面为单位来分配存储空间
  - 当某个段已经占用32个碎片区的页面 即一半后 就会以完整的的区为单位来分配空间
- 所以段的定义为某些零散的页面以及一些完整的区的集合









## 系统表空间结构