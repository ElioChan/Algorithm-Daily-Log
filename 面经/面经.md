- [C++](#c)
  - [++前置与后置](#前置与后置)
  - [new 和 malloc的区别 以及malloc的底层实现](#new-和-malloc的区别-以及malloc的底层实现)


# C++

## ++前置与后置
先看源码
<details>
<summary> operator++</summary>
<pre><code class = "language-cpp">

self &opertator++() {
    node = (linktype)((node).next);
    return *this;
}

const self operator++(int) {
    self tmp = *this;
    ++*this;
    return tmp;
}

</code></pre>
</details>

1. 返回类型的区别，前置++返回引用类型，后置++返回临时对象，是一个右值
2. 函数参数的区别，前置++无参数，后置++有一个int形参，主要是用于区分前置和后置++
3. 函数逻辑的区别，前置++直接在原对象上+1，后置++是先构造一个临时对象，然后原对象+1(调用前置++)，最后返回临时对象

Q&A:
- 为什么后置++不返回引用参数 而返回一个右值
  - 首先明确后置++的作用 是用原来的值进行计算 计算完成后再对原对象+1 所以返回的只能是原来的值 但是原来的值需要+1 所以不能返回原来的值的引用 那么只能新构建一个临时对象 若返回临时对象的引用 由于临时对象出了函数作用域后 就会被删除 所以引用也就失效了 所以直接返回临时对象
- 为什么后置++需要加const限定修饰词
  - 因为后置++不支持 x++++这种两次++的操作 由于前一次++得到的是x的副本 所以最后x只会加1次 而不是两次 所以需要加上const防止这种情况的出现
- 前置与后置相比 谁的效率更高 为什么？
  - 前置的效率更高 因为后置会涉及调用1次构造函数 和 1次析构函数
- 前置++是原子操作吗？后置呢？
  - 都不是 不论前置还是后置 都可以理解为a = a + 1的操作 首先取出a的值 放到寄存器 然后对a+1 最后将寄存器中a + 1的值赋给 a(的地址) 

## new 和 malloc的区别 以及malloc的底层实现
