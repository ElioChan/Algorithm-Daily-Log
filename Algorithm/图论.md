
这章简单记录一下遇到过的图论的数据结构的题目

# 欧拉路
欧拉路问题就是遍历图中的每一条边 每条边只能走一次 问怎么走可以走完全部的路 就是一笔画出图的问题

定义：
- 通过图中所有边恰好一次且走遍所有顶点的通路称为欧拉通路
- 通过图中所有边恰好一次且走遍所有顶点的回路称为欧拉回路
- 具有欧拉回路的无向图称为欧拉图
- 具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图

判断图是否是欧拉图或者半欧拉图
- 对于无向图G，G是欧拉图当前仅当G是连通的且没有奇度顶点
- 对于无向图G，G是半欧拉图当且仅当G是连通的且G中恰好有0个或2个奇度顶点
- 对于有向图G，G是欧拉图当且仅当G的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同
- 对于有向图G，G是半欧拉图当且仅当
  - 如果将G中的所有有向边退化为无向边时，那么G的所有顶点属于同一个强连通分量
  - 最多只有一个顶点的出度与入度差绝对值为1
  - 所有其他顶点的入度和出度相同

确定图为欧拉图或者版欧拉图后 图中至少存在一条欧拉通路

首先需要确定路的起点 有之前的分析可知 若存在一个点的入度 = (出度 - 1) 则这个点为起点 然后从这个点开始找到一条欧拉通路
利用Hierholzer 算法


所以一般欧拉路的题目的做法
1. 将问题转化为图 建图
2. 构建edge邻接矩阵 以及计算每个顶点的出度和入度
3. 根据顶点的出度和入度找到起点
4. 利用Hierholzer 算法计算欧拉通路

Hierholzer算法说明：

不断的遍历每个节点的叶子节点并删除遍历过的节点 直到最后没有节点可以遍历了 一步步往回走 加入路径上的点 就得到了欧拉路的逆序

正确性：因为最后返回的一定是那个出度<入度的点 即终点 因此一步步往回走即为欧拉路了 

<pre><code>
    void dfs(int curnode) {
        vector<int> &e = edges[curnode];
        while (!e.empty()) {
            int nextnode = e.back();
            e.pop_back();
            dfs(nextnode);
            ans.push_back(vector<int>{curnode, nextnode});
        }
    }

</code></pre>


模板题

LC332 LC2097