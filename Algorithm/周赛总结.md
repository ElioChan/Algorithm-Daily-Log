# 周赛307
2022/8/21
这周又是签到题选手 呜呜呜呜太难了 不过比前两次好多了 前两次完全没有思路 只能看着大佬在评论区里面谈笑风生
这次第一题就花了我18分钟 还WA了一次 这个时候大佬都已经全部AC了......
主要原因还是自己的代码功底不够 类似第三题 思路是有的 不过完全不知道该怎么重构二叉树 毕竟有些节点会有三个子节点 而且怎么逆转方向？？？
还有第四题 和之前做过的前K个高频元素很像 大概猜到是用堆来做 不过没敢想 T4不是现在的我可以企及的 第二题的话 大致的思路是有的 不过对对于不能有前导零这一点不会处理 当时想着是把有零的情况单独拿出来讨论 后面发现生成回文的思路就不太对

## T1 LC6152 赢得比赛需要的最少训练时长
一眼贪心嘻嘻 和之前做的LC134 加油站很像 基本一样
对于精力 由于只会消耗 不会增加 所以遍历一边数组求出需要消耗的精力和+1 - 初始的精力即为需要训练的时间
对于经验 由于击败对手后经验会增加 这个就和加油站类似了 关键在于求出最少需要的初始经验
从头遍历经验数组 res = max(res, experience[i] + 1) ; res += ecperience[i] 即可 就是说每到一个对手面前 比较已有的精力和至少需要的精力 取最小值 然后击败对手后 此时的经验即击败对手i需要的最少的经验 再加上经验i 比较和下一个对手 击败最后一个对手后 就得到了 击败所有对手所需要的经验 这个时候减去所有对手的经验之和 即为我们自己初始所需要的经验 

这题WA了一遍的原因在于上面那两个最后结果的减法没有判断是否小于零 这里小于零就代表题目给的初始值已经够了 不需要训练

## T2 LC6166 最大回文数字
给定一个仅有数字0-9组成的字符串Num, 找出能够使用Num中数字形成的最大回文整数并以字符串的形式返回 该整数不含前导零 

- 原始思路：统计所有数字出现过的次数 所有偶数次的放两边 奇数次的挑一个最大的放中间 最后返回even + odd + reverse(even)  
问题在于奇数次的比如3可以选用2个变成偶数次 
- 题解思路：统计所有数字出现的次数 从9往0遍历 将所有的数字次数-2 然后放进结果left = right 最后所有的数字的count为1或者0 然后再从9往0遍历 遇到1就放进left后面然后结束 最后返回left + right  
对于前导零的处理在于第一次从9往0遍历时 若left为空 且遍历到0了 则终止 因为此时的0读进来为前导零

## T3 LC6154 敢让二叉树需要的总时间
- 原始思路：这个总时间应该等于以目标节点为根节点的树的深度 求深度 会！ bfs  但是不会重新构建一个以目标节点为根节点的树 然后就卡住了
- 题解思路：构建一个关联矩阵 表示每个节点与那些节点向量 然后使用dfs遍历这个图 计算最大深度
1. 为了构建关联矩阵 需要直到维度 所以第一次dfs遍历得到节点的最大只
2. 构关联矩阵 遍历dfs加入每个节点与那些节点相连
3. 遍历关联矩阵dfs得到最大深度


# 周赛308
2022/9/1
由于这次周赛做出来三题所以飘了 所以忘记记录  今天补一下
这次是三题选手 嘻嘻嘻 第一题花的时间有点久 第二题倒是很快就做出来了 第三题一开始看错题目了 后面由于罗老师开会要共享屏幕 所以没办法改 结果只能会开完再改 就来不及了 不过最后还是改出来了 就算自己做出来了嘻嘻

## T1 LC2389 和有限的最长子序列
题意：给定一个数组num以及一个数组query 要求求出num中值不超过query[i]的最长子序列的长度
- 原始思路：由于是求自序列的长度 一开始想的是动规 但是不会写 然后想到贪心 因为是子序列 所以无关顺序 所以可以将原数组进行排序 然后求前缀和 这样可以保证求出来的序列是最长的  之所以花了28分钟才做出来 是因为之前思路太乱了 一直试图用动规做 但是找不到递推公式 所以就放弃动规了

## T2 LC2390 从字符串中移除星号
题意：给定包含若干个星号*的字符串s 每次移除星号 *左边的字符 并移除星号本身
- 原始思路：就是栈的简单应用 依次读取字符 遇到星号就pop出栈顶元素即可 然后这题本来需要一个栈存储读取的元素 之后再从栈中恢复字符串 但是前几天刚好做到一个题看到一个题解说是 字符串直接有栈的操作pop_back() push_back() 所以就不需要栈作为中介了

## T3 LC2391 收集垃圾的最少总时间
题意：三种垃圾由三种垃圾车进行回收 给一个字符串数组表示第i户人家的垃圾种类与数目 比如'MPGG'表示G玻璃垃圾有2单位 M金属垃圾有1单位 纸垃圾有1单位
三类垃圾车回收一单位垃圾需要一单位时间 然后再给一个时间数组表示每辆垃圾车在相邻的房子之间需要行驶的时间 三辆车速度一样 每次只能一辆垃圾车在行驶或者收拾垃圾 且从同一个起点出发 问至少需要多少时间处理所有的垃圾
- 原始思路：直接贪心 由于收拾垃圾时间等于字符串的长度之和 所以直接相加即可 剩下的就是每辆车的行驶时间 只要计算出最远出现对应垃圾的下标 再计算一下行驶时间数组的前缀和即可得到行驶时间 一开始看错题目以为是每类垃圾车时间不同 直接搞错题意 所以一直通不过示例 后来想通了 又去开会了 最后写出来了 不过代码可以优化 可以看出三辆垃圾车需要做的事是相同的 所以可以写个函数 调用三次 这样可能更快

## T4 LC2392 给定条件下构造矩阵
emmm没看题目 下次再说吧


# 周赛309
mihoyo的题好难 参加的人好多....又是1题选手 不过竟然还有前4000....这次的第二题和第三题确实没有思路 主要是卡在第二题 有一点思路又没有完全有 就想了很久
第一题就不讲了
## T2 LC6168 恰好移动K步到达某一位置的方法数目
题意： 给定两个位置startPos 和 endPos，以及步数k,问有多少种走法可以走k步从start走到end 每次走一步
- 原始思路：一开始想的用动规 试图找到走k步和走K-1步之间的关系 最后没找到 然后手动模拟了以下例子 发现只有当k-d是偶数的时候才可以有多种走法 因为多种走法的实质是从start走到end的这段长度为d的路程中 多出来的k - d步需要在某些点上走一个来回 比如1->2走三步 可以1->2->1->2 或者1->0->1->2 也就是在1这个点走了一个圈然后再回到普通的路线1->2上 所以我就开始找这个规律 有多少种走圈的走法 结果最后还是没找到
- 题解：将设沿着从start往end的方向走了a步 反方向走了k-a步然后到达了end 则一共有C(a, k)种走法 即在k步种选择a步时沿正方向走 同时我们根据距离有 
a - (k - a) = abs(end - start) = d  ==> a = (k + d) / 2因此只有k + d为偶数时才有可能走多步 这个和我之前发现的规律是一致的
因此最后就转变为求C(a,k)可以利用组合数的公式C(j,i) = C(j, i - 1) + C(j - 1, i - 1)进行递归计算

## T3 LC6169 最长优雅子数组
Tag: 位运算
题意：给定一个正整数组成的数组，找出其中的最长优雅子数组
优雅：即数组种任意两个元素按 与 运算结果为0  (即任意两个元素 二进制表示中的1的位置不同)
子数组：数组种连续的一部分
- 题解：由于是求子数组 连续的 所以考虑滑动窗口
关键点：本质上要求滑动窗口里的元素的相同的位的上不能有重复的1 因此可以将所有的元素进行或运算 或运算 会将所有的1都统计出来 因此只要新加入窗口的元素与所有元素的或运算后的结果 的与运算 == 0 即可 若要移动窗口左边界 即将元素剔除出去 可以利用异或运算 因为此时窗口内部是优雅的 即每一位上至多只有一个元素为1 所以利用异或剔除左边边界元素所包含的1即可
 


 # 周赛310 
 2022/9/13
 上周末又忘记及时记录了.....好吧 今天补上<br>
 这次周赛忘记了...尴尬 到11.30才想起来 然后顾不上吃饭 匆匆忙忙打开力扣做题 一看时间 嚯 大佬们10分钟解决战斗 还有一个WA了一次 还是11分钟结束战斗...厉害 看来还是手速场 感觉最近稳定2题选手了 第三题每次看题解能学到一些东西<br>
 然后就是这次 看来排名第一的大佬的代码 真的学到很多！！！

 ## T1 LC2404 出现最频繁的偶数元素
 题意：给定一个整数数组 返回出现最频繁的偶数元素 若存在多个 返回最小的 若不存在 返回-1<br>
 思路：利用hash表 边存边更新最频繁的结果

 这里比赛的时候之所以选择边存数据边更新结果 主要是因为自己不知道怎么遍历哈希表.....太菜了
 for(auto& [k,v] : mp) if(v > ansv) ans=k, ansv=v;

 ## T2 LC2405 子字符串的最优划分
 题意：把字符串划分为一个或多个子字符串 要求每个子字符串中每个字符都是唯一的 即只能出现1次 返回最少的子字符串数量<br>
 思路：维护一个子字符串 然后遍历原字符串 若子字符串中出现过字符 则将子字符串加入vector 并清空子字符串 否则就将字符加入子字符串 最后返回vector.size()即为字符串的数量<br>
 大佬的题解：学习！ bitset <br>
 bitset类由一些位组成 可以看作是一个0-1vector 下标为0表示最高位 不过这个类可以直接提供一些位运算以及比特的设置<br>
 - set()将所有位都设为1, set(size_t pos, bool val = true)将第pos位设为val
 - reset()将所有位都设为0, reset(size_t pos)将第pos位设为0
 - flip()将所有位都翻转(0->1, 1->0), flip(size_t pos)翻转第pos位
 - test(size_t pos) const;测试第pos位是否为1
 - bool any() const; 判断是否有某位为1
 - bool none() const; 判断是否全部为0
<pre><code class="language cpp">
class Solution {
public:
    int partitionString(string s) {
        int ans=0;
        std::bitset<128>vis;
        for(char c:s){
            if(vis[c])ans++,vis.reset();
            vis.set(c);
        }
        return ans+1;
    }
};
</code></pre>
大佬这个写法其实思路差不多 不过使用了bitset来实现 因为字符串的ASCII范围在0-127 所以设了一个128位的bitset来表示每一位是否出现过

 ## T3 LC2406 将区间划分为最少数组
 Tag: 贪心
首先将数组按照左边界升序排序 维护一个表示每组结束时间的列表
新加入的区间的可以接在所有结束时间小于他的开始时间的组的后面 若存在 则一定包含结束时间最小的那个组 我们统一选择接在结束时间最小的组的后面 
- 其实只要存在这样的组 则接在那一组后面都是没差别的 假设又两个组的结束时间为a < b 此时新加入的区间[c, d]满足a < b < c <= d 则由两种接法 a -> c或者 b -> c 由于我们之前按照左边界升序排序  所以后面加入到区间的开始时间e >=c  若 e > d则可以选择a或b组都可以 若我们之前选择a->c 则这次选择b->e ； 若之前选择b->c 则这次选择a->e 可以看出选择a->c 或b->c并没有差别
接在结束时间小的组后面 同时更新这一组的结束时间

通过上述分析 可以选择维护一个结束时间的小顶堆 
- 当新的区间的开始时间大于堆顶 即最小的结束时间 更新那一组的结束时间 即pop堆顶 加入新区间的结束时间  
- 当新的区间的开始时间小于堆定 即最小的结束时间 则小于所有的结束时间 因此需要增加一组

###  priority_queue
初始化：
priority<int> pq; 默认是大顶堆 底层容器默认为vector 也可以用deque
priority<int, vector<int>, greater<int>> pq;  若要使用小顶堆 第三个参数要用greater<type> 同时 C++中参数半缺省只能缺省右边的连续的参数 所以不能缺省中间的vector<int>参数


# 双周赛87
2022/9/18
最近真的稳定两题选手 第三题不论简单还是难都过不去.....

## T1 LC6184 统计共同度过的日子数
题意：给定两个人到达某个地点的日期字符串 均以"mm-dd"的格式给出 求出两人同时在一个地方的时间长度  假设在一年中 而且不是闰年

思路：总的来说就是对字符串的一个处理 将两人的日期转换成数字之后 求出两个时间区间的相交的长度即可 

 所以主要在于字符串的处理上面 我写的的代码可繁琐了 可以把处理日期的代码写成函数 然后调用一下  这样代码可读性会好很多 整体也清晰一点
## T2 LC6185 运动员和训练师的最大匹配数
题意：给定两个数组 分别表示运动员和训练师的能力值 当运动员 <= 训练师时 可以匹配 求出匹配成功地最大值

思路：贪心吧 首先把两个数组升序排序 然后双指针遍历两个数组 统计匹配成功的个数
## T3 LC6186 按位或最大的最小数组长度
题意：给定一个数组 返回一个数组 这个数组的每一位表示以num[i]开始的子数组或的结果为所有以num[i]开始的子数组中最大的 且长度最短

思路：一开始想的时利用类似前缀数组的思想求出或的后缀数组 然后区间[l, r]或的而结果就等于post[l] ^ post[r] 但是想想这样好像不太对 

后来看题解的时候意识到 后缀数组的结果就是以num[i]开始的子数组中最大的那个 所以你往后遍历 直到结果大于等于后缀数组的值 就找到了最短的 可是这样的考虑最坏的情况时间复杂度太大了 n^2级别 会TLE 

题解：


LC1521
<pre>
<code class = "language cpp">
class Solution {
public:
    int closestToTarget(vector<int>& arr, int target) {
        int ans = abs(arr[0] - target);
        vector<int> valid = {arr[0]};
        for (int num: arr) {
            vector<int> validNew = {num};
            ans = min(ans, abs(num - target));
            for (int prev: valid) {
                validNew.push_back(prev & num);
                ans = min(ans, abs((prev & num) - target));
            }
            validNew.erase(unique(validNew.begin(), validNew.end()), validNew.end());
            valid = validNew;
        }
        return ans;
    }
};
</code></pre>



## T4 LC6187 完成所有交易的初始最少钱数
题意：给定一个交易二维数组：[[cost_i, cash_back_i],...] 每经过一次交易有money = money - cost[i] + cash_back[i] 交易能够进行的前提是 money >= cost[i] 把交易以任意顺序进行排序 求出可以完成任意顺序的所有交易的最少初始Money  

思路：如果只考虑给定顺序的交易数组 和之前做过的加汽油的问题是类似的 不过这边的要求是要求任意顺序都能完成交易 所以这里得先求出花费最多的顺序 很遗憾 我不会


首先对投资项目进行分类，要么最终亏了，要么不亏。那么，对于任意一个交易 A = [cost, gain]A=[cost,gain]，最坏的情况自然是我们 把除了它自身，所有亏损的投资都完成了之后再考虑交易 AA，这时候剩下的钱不能少于 costcost。

具体实现：首先把所有 亏损 的项目求个总亏损额 SS，然后逐个考虑交易，对于交易 A = [cost, back]A=[cost,back]，如果它亏损，需要在总和 SS 中减去 AA 的亏损额，得到其他项目的总亏损额 S'S 
′
 ，此时初始钱数至少为 cost + S'cost+S 
′
 ；如果它不亏损，那么无需在总和 SS 中减去，初始钱数至少为 cost + Scost+S。答案就是对每个交易求得的最大值。

正确性证明：假设我们最终求得的结果是 resres 。

首先，任何一种顺序下的最小初始不会超过 resres，因为对于任何一个交易，在他之前的亏损额都不会超过除了它自身的所有亏损额，因此按照前述算法求得的 resres 足以支撑该交易，因此最终答案不会大于 resres；
其次，存在一种排序，使得最小初始钱数就是 resres，假设之前我们在求 resres 的过程中，是交易 AA 把 resres 设为最大值的，那么我们只需把所有亏钱的交易安排在交易 AA 之前，那么这个排序的最小初始就是 resres，因此最终答案不会小于 resres。
综上所述，最终答案就是按照上面算法所求的 resres。



先把所有的亏损计算出来为S 然后对于亏损的的交易 除去自身的亏损外 仍需要至少cost_i来完成交易 因此 至少需要S - (cost - cash)  + cost
对于盈利的交易 需要考虑把他放在所有的亏损后面进行 则需要S+ cost_i来完成交易 
所以最终的结果取最大值即可


总结：可以将所有的交易分类：亏损  不亏 
当你完成所有的亏损交易时 只要当你第一笔不亏的交易是cost最大 那么你后面的交易都能被满足 因为cash_i > cost_i > cost_(i+1) 
而你要完成所有的亏损交易至少需要满足最后一笔亏损的交易  所以只要满足所有的亏损交易作为最后一笔亏损情况

题解：


# 周赛311
2022/9/18
双周赛上大分 周赛掉大分呜呜呜 过山车一样 这次仍然是两题选手 不过第二题WA了两次 哭了 直接4000+
这次的题目真的挺简单吧 反正第一题是真的水.....

## T1 LC6180 最小偶倍数
题意：给定n 返回n和2的最小倍数...... 最水的周赛题了 真 签到题 我甚至还怀疑了两分钟 怕有陷阱 
n为奇数 直接返回2n; 偶数 直接返回n

## T2 LC6181 最长的字母序连续字符串的长度
题意：给定一个字符串 求出最长的字母序连续字符串 就是要求abcdef这样的必须连在一起的字符串 求最长

思路： 根据题意进行模拟即可

## T3 LC6182 翻转二叉树的奇数层


## T4 LC6183 字符串的前缀分数和

