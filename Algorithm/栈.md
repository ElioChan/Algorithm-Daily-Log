目前遇到的几类题目：
1. 栈与文件路径
2. 栈与字符串计算
3. 栈与递归
4. 栈与括号匹配



# LC71 简化路径
将unix路径简化为规范路径
1. 将路径根据'/'拆分为目录 
2. 若目录= '.' 则不动 = ’..'则返回上一级 若都不是 则加入目录路径

一开始想的是利用vector存这个目录 然后利用stack pop得到最后的规范路径 但是这样还需要stack的存储空间 多了一倍 所以想直接利用stack进行模拟 用stack倒是可以直接搞出目录 但是我们最后需要恢复成字符串 而stack是后进先出 和目录生成的规则不同 所以又想用queue 但是pop的是队首元素 不符合 最后用了deque 

这里用deque的点在于 push元素的时候需要pop队尾元素 但是最后输出的时候先输出队首元素 这两种规则是反着来的 所以无法用单一的stack或者queue模拟 直接用deque

还有一个新语法 move 用于vector这类容器添加元素时

比如str  = "hello" 

vector<string> s.push_back(str) 是先将str拷贝一遍 然后将拷贝得到的对象加入vector

可以用move这个语法 省去拷贝这个函数 节省空间 s.push_back(move(str)) 这样的做的缺点在于move后str就为空了 不过也可以算个优点 相当于move函数不复制 而是直接把str中的value移动到vector中


# LC224 基本计算器
给定字符串表达式s 计算s s中可能包含多余的空格 但不会有两个连续的操作符即不会出现 ++ -- 这样的操作符 这里只考虑加减两种运算 数字有正负 
1. 处理空格
2. 处理括号
3. 处理数字
4. 处理操作符
5. 处理正负号
主要是以上5点 整体利用双栈： nums ops分别存放数据以及操作符来实现
1. 首先将字符串总的空格删去 便于后续操作 可以使用string自带的find函数 然后删除 或者自己写一个快慢双指针的函数 记得测试函数是否正确运行
2. 然后括号的优先级最高 所以优先对括号进行操作
- '(' 直接入ops
- ')' ops元素出栈 并进行计算 直到栈顶元素为'(' 进行匹配 pop栈顶元素即可 这里计算可以写一个函数calc 参数为两个栈 主要就是nums输出两个元素 ops输出操作符 因为只有加减 没有优先级判断  直接计算即可 把结果Push到nums中
3. 对于数字 这里不处理正负号 单纯的处理数字 利用字符串转10进制数即可 判断每个字符是为数字 这里题目给定了数据范围 若没有给定需要注意数据溢出
4. 处理操作符 正负号
这里操作符和正负号一起处理 因为都是 + - 两个符号 唯一需要注意的就是‘（-’这种情况 因为题目明确说不会出现连续的++ 或者 -- 所以无需考虑 遇到‘（-’时 往nums中push 0 变成(0-即可
在遇到操作符时 可以先将前面的运算都做了  就是代码中while的部分 

处理完for循环后 由于for循环里 只处理了包含括号的情况
因此在循环后 需要处理一遍没有括号的表达式

若进一步考虑乘除幂次取模等运算 只需要考虑维护一个运算的有限级 当遇到的操作符的优先级小于ops栈顶的操作符的优先级 则先计算ops内的操作符
```
while(!ops.empty() && ops.top() != '(')  {
    if(oper_pri[ops.top()] >= oper_pri[c]) calc(nums, ops);
    else break;
}
```