# 简介
这篇主要介绍有关动态规划的问题 借鉴别人说的一句话：动态规划的问题本质上考察的是如何转化为<mark>背包问题</mark>  
因此动态规划的主要分为两部分：  
1. 背包问题
2. 转化为背包问题

对于背包问题，有很多的种类，最基础的是0-1背包问题，其他的暂时还没有接触到，所以下面介绍0-1背包问题

# 背包问题
背包问题泛指一类 给定价值与成本 并 限制决策规则, 问如何实现价值最大化
## 0-1背包问题
0-1背包问题值给定物品价值与体积(对应给定价值与成本)，在规定的背包容量下(对应限制决策规则)，如何选择装入背包的物品使得价值最大  
我们考虑一个二维数组dp[i][j]表示在前i件物品种选择装入容量为j的背包 如何实现价值最大化 那么0-1背包问题就是返回dp数组的右下角的值  
对于第i+1个物品 我们有两种选择：装入背包或者不装   
若装入背包 则dp[i+1][j] = dp[i][j - weight[i + 1]] + value[i + 1] 即利用前i件物品装入背包容量为j - weight[i]的最大价值 再加上物品i的价值  
若不装入背包 则dp[i+1][j] = dp[i][j] 因为没有装入第i+1件物品 所以和前i件物品的选择是一样的
同时我们要求最大化 所以dp[i+1][j] = max(dp[i][j], dp[i][j - weight[i + 1]] + value[i + 1])

通过上述的递推的方式即可得到整个dp二维数组 前提是需要对dp数组进行初始化 一般是第一列以及第一行 具体视题目而定  
对于0-1背包问题的话就是 第一列表示容量为0 则无法装入任何东西 因此价值为0; 第一行表示只考虑是否装入第一件物品 所以若容量大于第一件物品重量 则价值为第一件物品的价值

<mark>优化为一维数组</mark>
对于上述地推过程，我们可以发现对于第i+1行的dp数组 只用到了第i行的dp数组进行计算  
因此我们考虑用一维数组进行优化 即dp[w] = max(dp[w], dp[w - weight[i]] + value[i])
由于我们需要用dp[w - weight[i]]这个数据 而这个数据是第i轮的数据 在第i+1轮计算时 若从左往右遍历 则这个值会被修改 因此我们需要从右往左遍历
<strong>dp[w]要调用的是第i层循环还没有更新过的值</strong>

## 完全背包问题
相比于0-1背包问题，完全背包问题对于物品可选择的次数不做限制，即0-1背包问题每样物品只能用一次，选择放与不放; 而完全背包问题每件物品可以多次选择，可以选择不放或者放一件 放两件 放三件......  

这里直接看完全背包问题的一维数组的情况，在0-1背包问题中，外层循环是物品，内层循环是背包容量，而在其一维数组的情况中我们内层循环是从后往前遍历的， (之前解释过，从后往前遍历是为了保证每个物品只被选择一次，因为在递推公式中需要用到的数据是第i-1轮的数据 若从前往后 则调用的数据变成了第i轮的数据 相当于一个物品重复考虑了)   
而在完全背包问题中，我们对于物品选择的次数不再做限制，即每个物品可以多次选择，所以我们双层循环依然都是从前往后遍历，但是内外层循环的先后顺序会有变化，在0-1背包问题中由于内层对于背包容量的循环是从后往前的，固定了每个物品只能选择一次，所以内外循环互换顺序不会造成影响; 但是对于完全背包问题，就会有影响了，这里先给出结论：
1. 外层遍历物品，内层遍历背包容量————求组合数(即不考虑顺序)
2. 外层遍历背包容量，内层遍历物品————求排列数(即考虑顺序)    

例子LC518 零钱兑换II  
题目要求：给定coins数组以及目标target 求有多少种组合可以得到target  
分析：这题不是单纯的完全背包问题(求是否能够装满背包 或者说背包可以得到的最大价值 递推公式为dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 需要注意对于单纯的完全背包问题 交换内外层顺序也是没有关系的) 而是求装满背包的组合数 所以递推公式为dp[j] += dp[j - coins[i]]   

若我们先遍历背包容量即target， 再遍历coins 则我们会一个一个确定dp[j]的值 因此后面的dp[j]在计算时调用前面的值 调用的是最终的结果 所以会有重复的元素出现 即认为同一个元素在不同的位置出现表示两种不同的结果 即注重顺序的排列  

而若先遍历coins， 再遍历背包容量target，则后面新加入的集合中一定是数字会包含更大的数字，也就是说这个组合中他的元素的相对顺序与原来的coins数组的顺序是相同的，所以不会存在元素相同但顺序不同的情况，所以这里我们最后计算得到的是组合数

具体的例子：LC377 组合总和IV
题目要求：给定一个由不同整数组成的数组nums，和一个目标整数target，从nums中找出并返回总和为target的元素组合的个数，每个元素可以重复使用
分析：这里的要求和LC518是一样的 都是求组合数 所以也要求外层遍历物品 内层遍历背包容量
举例：nums[] = [1, 2, 3] target = 4
- 若外层遍历target 内层遍历物品 则内层每循环玩一遍都是确定一个位置的最终结果
j = 0 dp数组不变
j = 1 i = 0 nums[i] = 1 dp[1] += dp[1 - 1] = dp[0] = 1 即'1' + '0'
j = 2 i = 0 nums[i] = 1 dp[2] += dp[2 - 1] = dp[1] = 1 即'1' + '1'
j = 2 i = 1 nums[i] = 2 dp[2] += dp[2 - 2] = dp[0] = 1 即'2' + '0' 故2一共有两种集合 1+1 2+0
j = 3 i = 0 nums[i] = 1 dp[3] += dp[3 - 1] = dp[2] = 2 即'1' + dp[2] = '1' + '1' + '1'/'1' + '2'
j = 3 i = 1 nums[i] = 2 dp[3] += dp[3 - 2] = dp[1] = 1 即'2' + dp[1] = '2' + '1' 从这里可以看出2出现在1的前面与原数组的相对顺序不相符
j = 3 i = 2 nums[1] = 3 fp[3] += dp[3 - 3] = dp[0] = 1 即'3' + '0' 故3一共有4种集合 其中1 2 与 2 1 是重复的
- 若外层遍历物品 内层遍历target 则内层循环每一遍都是确定一个物品
i = 0 nums[i] = 1 所有的dp更新为1 都表示为1+1+1+1的形式
i = 1 nums[i] = 2 dp[2] += dp[2 - 2] = dp[0] = 1 即'2' + '0';  dp[3] += dp[3 - 2] = dp[1] = 1 即'1' + '2' 还有1+ 1+ 1一共2种
dp[4] += dp[4 - 2] = dp[2] = 2 即dp[2] + '2' = 1 + 1 + 2/ 2 + 2 同时还有之前的1+1+1+1 一共三种



